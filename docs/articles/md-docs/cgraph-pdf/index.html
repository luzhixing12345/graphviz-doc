<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/dot.css /><link rel='stylesheet' href=../../../css/c.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/graphviz-doc.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">Cgraph-pdf</a><ul><li><a href="#h2-1">前言</a></li></ul><ul><li><a href="#h2-2">介绍</a></li></ul><ul><li><a href="#h2-3">Graph Objects</a></li></ul><ul><li><a href="#h2-4">Graphs</a></li></ul><ul><li><a href="#h2-5">Nodes</a></li></ul><ul><li><a href="#h2-6">Edges</a></li></ul><ul><li><a href="#h2-7">Traversals</a></li></ul><ul><li><a href="#h2-8">External Attributes</a></li></ul><ul><li><a href="#h2-9">Internal Attributes</a></li></ul></li></ul></div><div class='markdown-body'><blockquote><p>翻译自: <a href="https://graphviz.org/pdf/cgraph.pdf" target="_blank">https://graphviz.org/pdf/cgraph.pdf</a></p></blockquote><blockquote><p>有关 graphviz 的C库API 的使用 C-API 部分</p></blockquote><h1 id="h1-0">Cgraph-pdf</h1><h2 id="h2-1">前言</h2><p>示例代码在 code_examples/ 下, 在本文的对应章节均有具体代码示例, 在您按照前文配置好环境之后可直接编译运行</p><pre class="language-shell"><code><span class="Token Keyword CD">cd</span><span class="Token SPACE"> </span><span class="Token ID">code_examples</span><span class="Token LF">
</span><span class="Program Token ID">make</span><span class="Token LF">
</span><span class="Program Token PATH">./example1</span></code></pre><p>除此之外 example/ 下还有一个 <code>ast.dot</code>, 这是一个辅助用的dot文件示例, 您可以使用 vscode 查看或运行 <code>./example0</code> 查看</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230426141650.png" alt="20230426141650"></p><p>所有的函数都是 <code>ag</code> 开头, 变量类型是 <code>Ag</code> 开头, 指针多.</p><h2 id="h2-2">介绍</h2><p>Cgraph是一个用于图形编程的C库.它定义了由带属性的节点、边和子图组成的图形所需的数据类型和操作.属性可以是方便的文件I/O的字符串名称-值对,也可以是内部的C数据结构,用于高效的算法实现.</p><p><b>Cgraph旨在表示图形</b>;它不是像最短路径或网络流这样的更高级算法的库.我们将这些视为在Cgraph之上编写的更高级别的库.在Cgraph的设计中,努力追求时间和空间效率.基本(未带属性)图形表示每个节点需要104个字节,每个边需要64个字节,因此存储具有数百万对象的图形是合理的.对于带属性的图形,Cgraph还维护一个内部共享字符串池,因此如果图形的所有节点都具有 <code>color=red</code> ,则只会创建&quot;color&quot;和&quot;red&quot;的一个副本.还有其他专家可以利用的技巧以获得平坦的编码效率.例如,有方法来内联边列表遍历和内部数据结构访问的指令.</p><p>Cgraph使用Phong Vo的字典库 <code>libcdt</code> 来存储节点和边集.该库提供了一个统一的接口,可用于哈希表和伸展树,其API可用于一般编程(如在Cgraph程序中存储多重集合、哈希表、列表和队列).</p><h2 id="h2-3">Graph Objects</h2><p>几乎所有的Cgraph编程都可以通过指向这些数据类型的指针来完成:</p><ul><li><code>Agraph_t</code>: 一个图形或子图</li></ul><ul><li><code>Agnode_t</code>: 特定图形或子图中的<i>*节点</i>*</li></ul><ul><li><code>Agedge_t</code>: 特定图形或子图中的<i>*边*</i></li></ul><ul><li><code>Agsym_t</code>: 字符串-值对属性的<b>描述符</b></li></ul><ul><li><code>Agrec_t</code>: 图形对象的内部C数据记录属性</li></ul><p>Cgraph负责自己的内存管理;Cgraph数据结构的分配和释放始终通过Cgraph调用完成.</p><h2 id="h2-4">Graphs</h2><p>顶层图形(也称为根图)定义了节点、边、子图、数据字典和其他信息.图形具有名称和两个属性:它是有向的还是无向的,以及它是否是严格的(禁止多重边).可以指定一个图形是简单的(既没有多重边也没有环),或者可以具有多重边但不能具有环.</p><p><b>请注意,节点、边和子图存在于一个根图中.它们不能独立于该图形使用,也不能附加到另一个根图中.</b></p><p>以下示例使用约定,即 <code>G和g</code> 为 <code>Agraph_t*</code>(图指针),<code>n、u、v、w</code> 为 <code>Agnode_t*</code>(节点指针),<code>e、f</code> 为 <code>Agedge_t*</code>(边指针).</p><p>要创建一个新的空顶级有向图:</p><pre class="language-c"><code><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agopen</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="String Token STRING">&quot;G&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="PrimaryExpression Token Identifier ID">Agdirected</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="PrimaryExpression Token Identifier MacroDefine ID">NULL</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span></code></pre><pre class="language-c"><code><span class="Token HASH">#</span><span class="ControlLine Token Keyword Preprocess INCLUDE">include</span><span class="ControlLine Token Keyword Preprocess SPACE"> </span><span class="HeaderName ControlLine Token BraceDepth-0 LANGLE_BRACE">&lt;</span><span class="String Token HeaderName STRING">graphviz/cgraph.h</span><span class="HeaderName ControlLine Token BraceDepth-0 RANGLE_BRACE">&gt;</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agraph_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agopen</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">name</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agdesc_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">desc</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agdisc_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">disc</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><p>agopen的第一个参数可以是任何字符串,Cgraph不会对其进行解释,在将图形写入文件时记录和保留.</p><p>第二个参数表示图形的类型,应为如下四个变量之一</p><ul><li>Agdirected: 有向图</li></ul><ul><li>Agstrictdirected: 严格有向图(禁止多重边)</li></ul><ul><li>Agundirected: 无向图</li></ul><ul><li>Agstrictundirected: 严格无向图(禁止多重边)</li></ul><p>第三个参数是一个可选的指向一组方法的指针,用于覆盖Cgraph的某些默认行为,在大多数情况下可以为空指针NULL</p><p>您可以通过 <code>agnameof(g)</code> 获得图形的名称,并通过函数 <code>agisdirected(g)</code> 和 <code>agisstrict(g)</code> 获得其属性.</p><blockquote><p>见 example1.c</p></blockquote><p>您还可以通过读取文件来构建一个新的图形, 图形的名称、类型和包括属性在内的内容取决于文件内容.(第二个参数与上面提到的agopen的可选方法指针相同, 传 NULL 即可):</p><blockquote><p>见 example2.c</p></blockquote><pre class="language-c"><code><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agraph_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agread</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier BaseType Token Keyword VOID">void</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">chan</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agdisc_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">disc</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionName ID">agread</span><span class="BraceDepth-0 Token LPAREN">(</span><span class="Token Identifier ID">stdin</span><span class="PPtoken Token COMMA">,</span><span class="Token Identifier MacroDefine ID">NULL</span><span class="BraceDepth-0 Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token SPACE"> </span><span class="ExpressionStatement Token COMMENT">// 从标准输入中读</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token LF">
</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">FILE</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">fp</span><span class="Token DirectDeclaractor Identifier SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">fopen</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="String Token STRING">&quot;ast.dot&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;r&quot;</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionName ID">agread</span><span class="BraceDepth-0 Token LPAREN">(</span><span class="Token Identifier ID">fp</span><span class="PPtoken Token COMMA">,</span><span class="PPtoken Token SPACE"> </span><span class="Token Identifier MacroDefine ID">NULL</span><span class="BraceDepth-0 Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token SPACE"> </span><span class="ExpressionStatement Token COMMENT">// 利用 FILE *fp 读文件</span></code></pre><p>有时将图形表示为字符字符串str是很方便的.在这种情况下,可以使用以下方式创建图形:</p><pre class="language-c"><code><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agraph_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agmemread</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="QualifyType Token Keyword CONST">const</span><span class="QualifyType Token Keyword SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">cp</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">str</span><span class="Token DirectDeclaractor Identifier SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="String Token STRING">&quot;digraph { A -&gt; B; }&quot;</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionName ID">agmemread</span><span class="BraceDepth-0 Token LPAREN">(</span><span class="Token Identifier ID">str</span><span class="BraceDepth-0 Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span></code></pre><p>在上述代码中,我们首先定义了一个字符指针str,其中保存了一个表示有向图的字符串.然后,我们使用agmemread()函数将该字符串转换为一个Agraph_t类型的图形对象,并将其赋值给指针变量g</p><p>您可以将图形的表示写入文件:</p><blockquote><p>见 example3.c</p></blockquote><pre class="language-c"><code><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType INT">int</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Token DirectDeclaractor Identifier FunctionName ID">agwrite</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword VOID">void</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">chan</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier FunctionName ID">agwrite</span><span class="BraceDepth-0 Token LPAREN">(</span><span class="Token Identifier ID">g</span><span class="PPtoken Token COMMA">,</span><span class="Token Identifier ID">stdout</span><span class="BraceDepth-0 Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token SPACE"> </span><span class="ExpressionStatement Token COMMENT">// 直接在 标准输出 中输出</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token LF">
</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">FILE</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">fp</span><span class="Token DirectDeclaractor Identifier SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">fopen</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="String Token STRING">&quot;x.dot&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;w&quot;</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier FunctionName ID">agwrite</span><span class="BraceDepth-0 Token LPAREN">(</span><span class="Token Identifier ID">g</span><span class="PPtoken Token COMMA">,</span><span class="PPtoken Token SPACE"> </span><span class="Token Identifier ID">fp</span><span class="BraceDepth-0 Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token SPACE"> </span><span class="ExpressionStatement Token COMMENT">// 利用 FILE *fp 写文件</span></code></pre><p>agwrite()函数创建了一个图形内容和属性的外部表示(除了内部属性),稍后可以通过在同一个文件上调用agread来重构它.</p><blockquote><p>事实上如果需要在内部属性和外部字符串之间进行转换, 采用这种读写文件的方式要方便很多</p></blockquote><p>下面的三个函数可以获取数量</p><blockquote><p>见 example4.c</p></blockquote><pre class="language-c"><code><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType INT">int</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Token DirectDeclaractor Identifier FunctionName ID">agnnodes</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration SPACE"> </span><span class="Token Declaration COMMENT">// 节点数量</span><span class="Token Declaration LF">
</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType INT">int</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Token DirectDeclaractor Identifier FunctionName ID">agnedges</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration SPACE"> </span><span class="Token Declaration COMMENT">// 边数量</span><span class="Token Declaration LF">
</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType INT">int</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Token DirectDeclaractor Identifier FunctionName ID">agnsubg</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration SPACE"> </span><span class="Token Declaration COMMENT">// 子图数量</span></code></pre><p><b>注意最后需要使用</b> <code>agclose(g)</code> <b>删除图形及其关联的数据结构并释放它们的内存</b></p><p>还有一个有趣但不太常用的函数可以将图形文件的内容连接到现有的图形上, agconcat()函数将标准输入中的图形内容附加到现有图形g的末尾,并返回连接后的图形对象</p><pre class="language-c"><code><span class="PrimaryExpression Token Identifier ID">g</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agconcat</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">stdin</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier MacroDefine ID">NULL</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span></code></pre><h2 id="h2-5">Nodes</h2><p>在Cgraph中,节点通常由<b>唯一的字符串名称和由Cgraph分配的唯一的内部整数ID</b>来标识.(为方便起见,您还可以通过将节点名称设置为NULL来创建&quot;匿名&quot;节点.)即使在无向图中,节点也具有入边和出边集合.</p><p>一旦您拥有一个图形g,可以按以下方式创建或查找节点:</p><blockquote><p>见 example5.c</p></blockquote><pre class="language-c"><code><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agnode_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agnode</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">name</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword INT">int</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">createflag</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">n</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionName ID">agnode</span><span class="BraceDepth-0 Token LPAREN">(</span><span class="Token Identifier ID">g</span><span class="PPtoken Token COMMA">,</span><span class="String Token STRING">&quot;node28&quot;</span><span class="PPtoken Token COMMA">,</span><span class="PPtoken Token NUMBER">1</span><span class="BraceDepth-0 Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionName ID">agnode</span><span class="BraceDepth-0 Token LPAREN">(</span><span class="Token Identifier ID">g</span><span class="PPtoken Token COMMA">,</span><span class="String Token STRING">&quot;node11&quot;</span><span class="PPtoken Token COMMA">,</span><span class="PPtoken Token NUMBER">0</span><span class="BraceDepth-0 Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span></code></pre><p>第一个参数是要在其中创建节点的图形或子图.第二个参数是节点的名称, 如果为 NULL 则认为是一个<b>匿名节点</b></p><ul><li>当第三个参数为 1 时,有则返回节点, 如果节点不存在,则创建该节点.</li></ul><ul><li>当第三个参数为 0 时,Cgraph搜索以查找具有给定名称的现有节点,如果找不到则返回NULL</li></ul><p>函数agdegree可以给出节点在(子)图g中的度数,其中in和out选择边集.</p><pre class="language-c"><code><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType INT">int</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Token DirectDeclaractor Identifier FunctionName ID">agdegree</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">n</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword INT">int</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">in</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword INT">int</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">out</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType INT">int</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Token DirectDeclaractor Identifier FunctionName ID">agcountuniqedges</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">n</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword INT">int</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">in</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword INT">int</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">out</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><ul><li>agdegree(g,n,TRUE,FALSE)返回入度.</li></ul><ul><li>agdegree(g,n,FALSE,TRUE)返回出度.</li></ul><ul><li>agdegree(g,n,TRUE,TRUE)返回它们的和.</li></ul><p>函数agcountuniqedges与agdegree相同,除非最后两个参数都为TRUE.在这种情况下,一个环路只计数一次.</p><p>agnameof(n)返回节点的可打印字符串名称, 对于匿名边/节点返回 NULL</p><pre class="language-c"><code><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType CHAR">char</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agnameof</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier BaseType Token Keyword VOID">void</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><p>请注意,由于各种原因,<b>该字符串可能是一个临时缓冲区,可能会被后续调用覆盖</b>.因此,以下用法是<b>不安全的</b>:</p><pre class="language-c"><code><span class="PrimaryExpression Token Identifier FunctionCall ID">printf</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="String Token STRING">&quot;</span><span class="String Format Token STRING">%s</span><span class="String Token STRING"> </span><span class="String Format Token STRING">%s</span><span class="Control String Token STRING">\n</span><span class="String Token STRING">&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier FunctionCall ID">agnameof</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier FunctionCall ID">agtail</span><span class="Token PostfixExpression BraceDepth-2 UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="Token PostfixExpression BraceDepth-2 UnaryExpression RPAREN">)</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier FunctionCall ID">agnameof</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier FunctionCall ID">aghead</span><span class="Token PostfixExpression BraceDepth-2 UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="Token PostfixExpression BraceDepth-2 UnaryExpression RPAREN">)</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span></code></pre><p>因为当计算printf的参数时,缓冲区可能会被覆盖.需要分开写</p><p>可以使用agdelnode(g,n)从图或子图中删除节点.</p><blockquote><p>见 example5.c</p></blockquote><h2 id="h2-6">Edges</h2><p><b>当创建一条边时,第一个节点将被用作尾节点(tail),第二个节点将被用作头节点(head).这适用于有向图和无向图</b></p><blockquote><p>这里的头尾稍微需要记忆一下, a -&gt; b 中 a 是尾(箭头尾部), b 是头(箭头头部)</p></blockquote><p>边是节点对:在有向图中是有序对,在无向图中是无序对.</p><p>为了方便起见,有一个通用的边数据结构 <code>Agedge_t</code> 用于两种类型,其端点是tail和head字段.</p><pre class="language-c"><code><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agedge_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agedge</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">t</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">h</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">name</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword INT">int</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">createflag</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agedge_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">e</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">n1</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">n2</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier ID">n1</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agnode</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="String Token STRING">&quot;node1&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="PrimaryExpression Token Identifier MacroDefine ID">TRUE</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="PrimaryExpression Token Identifier ID">n2</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agnode</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="String Token STRING">&quot;node2&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="PrimaryExpression Token Identifier MacroDefine ID">TRUE</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionName ID">agedge</span><span class="BraceDepth-0 Token LPAREN">(</span><span class="Token Identifier ID">g</span><span class="PPtoken Token COMMA">,</span><span class="PPtoken Token SPACE"> </span><span class="Token Identifier ID">n1</span><span class="PPtoken Token COMMA">,</span><span class="PPtoken Token SPACE"> </span><span class="Token Identifier ID">n2</span><span class="PPtoken Token COMMA">,</span><span class="PPtoken Token SPACE"> </span><span class="String Token STRING">&quot;e28&quot;</span><span class="PPtoken Token COMMA">,</span><span class="PPtoken Token SPACE"> </span><span class="Token Identifier MacroDefine ID">TRUE</span><span class="BraceDepth-0 Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span></code></pre><p>在上面的代码中,我们首先使用agnode()函数创建了两个节点n1和n2,然后使用agedge()函数创建了它们之间的一条边e.agedge()函数的第一个参数是创建边的图或子图,第二个和第三个参数是边的起点和终点,第四个参数是边的标签(可以为NULL),第五个参数表示如果边不存在,则创建它(False则查询, 同 agnode).</p><p>n1和n2必须属于同一个图或子图.边的&quot;名称&quot;(更正确地说是标识符)被视为特定节点对之间边的唯一标识符.也就是说,<b>在任何给定的n1和n2之间,最多只能有一条名为e28的边,但是可能会有许多其他连接其他节点的边名为e28</b></p><p>如果使用 agedge 查找一个 NULL 的边, 如果 n1 n2 之间不存在边则返回 NULL, 如果存在则返回最后被创建的边.(见example7.c)</p><blockquote><p>虽然说可以重名, 但是从编写程序的角度来说用实现点,边的唯一 UID 应该也不算困难</p></blockquote><p>可以使用agtail(e)和aghead(e)返回e的端点</p><blockquote><p>见 example6.c</p></blockquote><p>由于边被实现为边对,因此有两个指向同一边的有效指针,因此简单的指针比较 (e1 == e2) 对于边的相等性是不起作用的, 可以使用宏 <code>ageqedge</code> 来做判断</p><pre class="language-c"><code><span class="Token COMMENT">// 是一个宏, 但可以类似看作如下函数定义</span><span class="Token LF">
</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType INT">int</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Token DirectDeclaractor Identifier FunctionName ID">ageqedge</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agedge_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">e0</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agedge_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">e1</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><p>对于 node 和 edge 有如下的一些函数可以使用, 根据函数名不难猜测用法</p><blockquote><p>见 example7.c</p></blockquote><pre class="language-c"><code><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agedge_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agfstin</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">n</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agedge_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agnxtin</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agedge_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">e</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agedge_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agfstout</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">n</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agedge_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agnxtout</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agedge_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">e</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agedge_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agfstedge</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">n</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agedge_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agnxtedge</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agedge_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">e</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">n</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><p>e-&gt;node的值是与从中获取e的节点相对应的&quot;其他&quot;端点.也就是说,如果e是节点n的出边(n是e的tail),则e-&gt;node是e的head. 例如遍历节点 n 的所有出边</p><pre class="language-c"><code><span class="Token COMMENT">// 遍历节点 n 的所有出边</span><span class="Token LF">
</span><span class="Token Keyword IterationStatement FOR">for</span><span class="Token Keyword IterationStatement SPACE"> </span><span class="BraceDepth-0 Token IterationStatement LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agfstout</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="PrimaryExpression Token Identifier ID">e</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="PrimaryExpression Token Identifier ID">e</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agnxtout</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="BraceDepth-0 Token IterationStatement RPAREN">)</span><span class="Token IterationStatement SPACE"> </span><span class="CompoundStatement BraceDepth-0 Token IterationStatement LCURLY_BRACE">{</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement Token IterationStatement SPACE">    </span><span class="CompoundStatement Token IterationStatement COMMENT">// do something</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement BraceDepth-0 Token IterationStatement RCURLY_BRACE">}</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement Token IterationStatement COMMENT">// 搜索u-&gt;v的边</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agedge</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">u</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">v</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier MacroDefine ID">NULL</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier MacroDefine ID">FALSE</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token SPACE"> </span><span class="ExpressionStatement Token COMMENT">// 这里搜索的是匿名边, 有且当</span><span class="ExpressionStatement Token LF">
</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agedge</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">u</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">v</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;e8&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier MacroDefine ID">FALSE</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span></code></pre><p>删除边的方法与删除节点的方法类似,可以使用函数agdeledge(g, e)来删除边e,并释放其占用的内存</p><h2 id="h2-7">Traversals</h2><p>Cgraph提供了用于迭代图对象的函数.例如,我们可以通过以下方式扫描图(有向或无向)的所有边:</p><blockquote><p>函数命名都应该算挺标准的了, 应该不难理解和推测, 见 example8.c</p></blockquote><pre class="language-c"><code><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agnode_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agfstnode</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agnode_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agnxtnode</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">n</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Keyword IterationStatement FOR">for</span><span class="Token Keyword IterationStatement SPACE"> </span><span class="BraceDepth-0 Token IterationStatement LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionName ID">agfstnode</span><span class="BraceDepth-1 Token LPAREN">(</span><span class="Token Identifier ID">g</span><span class="BraceDepth-1 Token RPAREN">)</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="PrimaryExpression Token Identifier ID">n</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="PrimaryExpression Token Identifier ID">n</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionName ID">agnxtnode</span><span class="BraceDepth-1 Token LPAREN">(</span><span class="Token Identifier ID">g</span><span class="PPtoken Token COMMA">,</span><span class="Token Identifier ID">n</span><span class="BraceDepth-1 Token RPAREN">)</span><span class="BraceDepth-0 Token IterationStatement RPAREN">)</span><span class="Token IterationStatement SPACE"> </span><span class="CompoundStatement BraceDepth-0 Token IterationStatement LCURLY_BRACE">{</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement Token IterationStatement SPACE">    </span><span class="Token Keyword IterationStatement FOR">for</span><span class="Token Keyword IterationStatement SPACE"> </span><span class="BraceDepth-1 Token IterationStatement LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agfstout</span><span class="Token PostfixExpression BraceDepth-2 UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="Token PostfixExpression BraceDepth-2 UnaryExpression RPAREN">)</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="PrimaryExpression Token Identifier ID">e</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="PrimaryExpression Token Identifier ID">e</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agnxtout</span><span class="Token PostfixExpression BraceDepth-2 UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="Token PostfixExpression BraceDepth-2 UnaryExpression RPAREN">)</span><span class="BraceDepth-1 Token IterationStatement RPAREN">)</span><span class="Token IterationStatement SPACE"> </span><span class="BraceDepth-1 CompoundStatement Token IterationStatement LCURLY_BRACE">{</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement Token IterationStatement SPACE">        </span><span class="CompoundStatement Token IterationStatement COMMENT">/* do something with e */</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement Token IterationStatement SPACE">    </span><span class="BraceDepth-1 CompoundStatement Token IterationStatement RCURLY_BRACE">}</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement BraceDepth-0 Token IterationStatement RCURLY_BRACE">}</span></code></pre><p>对于有向边,&quot;in&quot;和&quot;out&quot;的意义是显而易见的.对于无向图,Cgraph<b>根据创建边时两个节点的顺序分配方向(tail head)</b></p><p>但是如果在遍历过程中代码删除了一个边或节点,则对象将不再有效,无法获取下一个对象</p><pre class="language-c"><code><span class="Token Keyword IterationStatement FOR">for</span><span class="Token Keyword IterationStatement SPACE"> </span><span class="BraceDepth-0 Token IterationStatement LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agfstedge</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="PrimaryExpression Token Identifier ID">e</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="PrimaryExpression Token Identifier ID">e</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agnxtedge</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="BraceDepth-0 Token IterationStatement RPAREN">)</span><span class="Token IterationStatement SPACE"> </span><span class="CompoundStatement BraceDepth-0 Token IterationStatement LCURLY_BRACE">{</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement Token IterationStatement SPACE">    </span><span class="CompoundStatement Token IterationStatement COMMENT">// delete node n/edge e -&gt; error</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement BraceDepth-0 Token IterationStatement RCURLY_BRACE">}</span></code></pre><p>通常可以通过替换为以下代码处理, 即提前取得下一个节点:</p><pre class="language-c"><code><span class="Token Keyword IterationStatement FOR">for</span><span class="Token Keyword IterationStatement SPACE"> </span><span class="BraceDepth-0 Token IterationStatement LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agfstedge</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="PrimaryExpression Token Identifier ID">e</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="PrimaryExpression Token Identifier ID">e</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier ID">f</span><span class="BraceDepth-0 Token IterationStatement RPAREN">)</span><span class="Token IterationStatement SPACE"> </span><span class="CompoundStatement BraceDepth-0 Token IterationStatement LCURLY_BRACE">{</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement Token IterationStatement SPACE">    </span><span class="PrimaryExpression Token Identifier ID">f</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agnxtedge</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">e</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="ExpressionStatement Token COMMENT">// delete node n/edge e -&gt; ok</span><span class="ExpressionStatement Token LF">
</span><span class="CompoundStatement BraceDepth-0 Token IterationStatement RCURLY_BRACE">}</span></code></pre><p>遍历保证按照它们在根图中创建的顺序访问图的节点或节点的边</p><h2 id="h2-8">External Attributes</h2><p>图形对象可以具有相关的 <code>字符串名称-值</code> 对.当读取图形文件时,Cgraph的解析器会处理这些细节,因此属性可以在文件的任何位置添加.<b>在C程序中,必须在使用之前声明值.</b></p><p>Cgraph假定给定类型(图/子图、节点或边)的<b>所有对象具有相同的属性</b>, <b>即属性内部没有子类型的概念</b>.属性信息存储在数据字典中.每个图形都有三个(用于图/子图、节点和边),在调用这些字典的创建、搜索和遍历时需要使用预定义的常量 <code>AGRAPH</code>, <code>AGNODE</code> 和 <code>AGEDGE</code></p><p>因此,要为节点创建属性,可以使用:</p><blockquote><p>见 example9.c</p></blockquote><pre class="language-c"><code><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agsym_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">sym</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier ID">sym</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agattr</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier MacroDefine ID">AGNODE</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;shape&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;box&quot;</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token SPACE"> </span><span class="ExpressionStatement Token COMMENT">// 节点的形状变为正方形</span></code></pre><p>如果成功,sym指向新创建(或更新)属性的描述符.(因此,即使shape先前已声明并具有其他默认值,它也将通过上述方式设置为box)通过使用空指针作为值,可以使用相同的函数搜索图形的属性定义.</p><pre class="language-c"><code><span class="PrimaryExpression Token Identifier ID">sym</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agattr</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier MacroDefine ID">AGNODE</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;shape&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Constant Token PrimaryExpression NUMBER">0</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="BraceDepth-0 Token SelectionStatement LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">sym</span><span class="BraceDepth-0 Token SelectionStatement RPAREN">)</span><span class="Token SelectionStatement SPACE"> </span><span class="CompoundStatement BraceDepth-0 Token SelectionStatement LCURLY_BRACE">{</span><span class="CompoundStatement Token SelectionStatement LF">
</span><span class="CompoundStatement Token SelectionStatement SPACE">    </span><span class="PrimaryExpression Token Identifier FunctionCall ID">printf</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="String Token STRING">&quot;The default shape is </span><span class="String Format Token STRING">%s</span><span class="String Token STRING">.</span><span class="Control String Token STRING">\n</span><span class="String Token STRING">&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">sym</span><span class="Token PostfixExpression UnaryExpression POINT">-&gt;</span><span class="Token Identifier ID">defval</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="CompoundStatement BraceDepth-0 Token SelectionStatement RCURLY_BRACE">}</span></code></pre><p>如果已经有了一个 object 的指针 n, 可以直接利用 agattrsym 去获取属性</p><pre class="language-c"><code><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">n</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agsym_t</span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">sym</span><span class="Token DirectDeclaractor Identifier SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agattrsym</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;shape&quot;</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="BraceDepth-0 Token SelectionStatement LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">sym</span><span class="BraceDepth-0 Token SelectionStatement RPAREN">)</span><span class="Token SelectionStatement SPACE"> </span><span class="CompoundStatement BraceDepth-0 Token SelectionStatement LCURLY_BRACE">{</span><span class="CompoundStatement Token SelectionStatement LF">
</span><span class="CompoundStatement Token SelectionStatement SPACE">    </span><span class="PrimaryExpression Token Identifier FunctionCall ID">printf</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="String Token STRING">&quot;The default shape is </span><span class="String Format Token STRING">%s</span><span class="String Token STRING">.</span><span class="Control String Token STRING">\n</span><span class="String Token STRING">&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">sym</span><span class="Token PostfixExpression UnaryExpression POINT">-&gt;</span><span class="Token Identifier ID">defval</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="CompoundStatement BraceDepth-0 Token SelectionStatement RCURLY_BRACE">}</span></code></pre><blockquote><p>如果未定义属性,则两个函数均返回NULL</p></blockquote><p>可以使用 agnxtattr 去遍历所有属性:</p><pre class="language-c"><code><span class="PrimaryExpression Token Identifier ID">sym</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="Constant Token PrimaryExpression NUMBER">0</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token SPACE"> </span><span class="ExpressionStatement Token COMMENT">/* to get the first one */</span><span class="ExpressionStatement Token LF">
</span><span class="Token Keyword IterationStatement WHILE">while</span><span class="Token Keyword IterationStatement SPACE"> </span><span class="BraceDepth-0 Token IterationStatement LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">sym</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agnxtattr</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier MacroDefine ID">AGNODE</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">sym</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="BraceDepth-0 Token IterationStatement RPAREN">)</span><span class="Token IterationStatement SPACE"> </span><span class="CompoundStatement BraceDepth-0 Token IterationStatement LCURLY_BRACE">{</span><span class="CompoundStatement Token IterationStatement LF">
</span><span class="CompoundStatement Token IterationStatement SPACE">    </span><span class="PrimaryExpression Token Identifier FunctionCall ID">printf</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="String Token STRING">&quot;</span><span class="String Format Token STRING">%s</span><span class="String Token STRING"> = </span><span class="String Format Token STRING">%s</span><span class="Control String Token STRING">\n</span><span class="String Token STRING">&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">sym</span><span class="Token PostfixExpression UnaryExpression POINT">-&gt;</span><span class="Token Identifier ID">name</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">sym</span><span class="Token PostfixExpression UnaryExpression POINT">-&gt;</span><span class="Token Identifier ID">defval</span><span class="BraceDepth-1 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="CompoundStatement BraceDepth-0 Token IterationStatement RCURLY_BRACE">}</span></code></pre><p>假设某个对象已经存在属性,则可以使用其字符串名称或其Agsym_t描述符获取或设置其值.要使用字符串名称,我们有:</p><pre class="language-c"><code><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">n</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">str</span><span class="Token DirectDeclaractor Identifier SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agget</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;shape&quot;</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier FunctionCall ID">agset</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;shape&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;hexagon&quot;</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span></code></pre><p>如果属性经常被引用,则使用其描述符作为索引会更快,如下所示:</p><pre class="language-c"><code><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agsym_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">sym</span><span class="Token DirectDeclaractor Identifier SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agattr</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier MacroDefine ID">AGNODE</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;shape&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;box&quot;</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">str</span><span class="Token DirectDeclaractor Identifier SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agxget</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">sym</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier FunctionCall ID">agxset</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="PrimaryExpression Token Identifier ID">sym</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="String Token STRING">&quot;hexagon&quot;</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span></code></pre><p>Cgraph提供了两个辅助函数来处理属性.函数agsafeset首先检查属性是否已定义,如果没有定义,则使用默认值def定义它.然后将value用作分配给obj的特定值.</p><p>有时有用的是将一个对象的所有值复制到另一个对象中.这可以使用agcopyattr(void *src, void* tgt)轻松完成.这假定源和目标是相同类型的图形对象,并且src的属性已经为tgt定义.如果src和tgt属于同一根图,则这将自动成立.</p><blockquote><p>这里的 API 有点多, 不过大概意思都差不多, 读者可以参考 example9.c 的代码选择合适的方式使用. 关于都有什么属性以及属性都有什么值可选参考 <code>属性</code></p></blockquote><pre class="language-c"><code><span class="Token COMMENT">// 全局设置属性</span><span class="Token LF">
</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agsym_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agattr</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword INT">int</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">kind</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">name</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="QualifyType Token Keyword CONST">const</span><span class="QualifyType Token Keyword SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">value</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration COMMENT">// 首先检查属性是否已定义,如果没有定义,则使用默认值def定义它.然后将value用作分配给obj的特定值</span><span class="Token Declaration LF">
</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType INT">int</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Token DirectDeclaractor Identifier FunctionName ID">agsafeset</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier BaseType Token Keyword VOID">void</span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">obj</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">name</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="QualifyType Token Keyword CONST">const</span><span class="QualifyType Token Keyword SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">value</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="QualifyType Token Keyword CONST">const</span><span class="QualifyType Token Keyword SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">def</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration COMMENT">// 设置单个 object 的属性</span><span class="Token Declaration LF">
</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType INT">int</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Token DirectDeclaractor Identifier FunctionName ID">agset</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier BaseType Token Keyword VOID">void</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">obj</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">name</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="QualifyType Token Keyword CONST">const</span><span class="QualifyType Token Keyword SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">value</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration COMMENT">// 通过 Agsym_t * sym 设置, 适用于属性经常被引用的情况</span><span class="Token Declaration LF">
</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType INT">int</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Token DirectDeclaractor Identifier FunctionName ID">agxset</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier BaseType Token Keyword VOID">void</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">obj</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agsym_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">sym</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="QualifyType Token Keyword CONST">const</span><span class="QualifyType Token Keyword SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword CHAR">char</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">value</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration COMMENT">// 获取下一个属性</span><span class="Token Declaration LF">
</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType TYPEDEF_ID">Agsym_t</span><span class="Keyword Typedefine TypeSpecifier Token FunctionReturnType SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier FunctionName ID">agnxtattr</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agraph_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">g</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword INT">int</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">kind</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agsym_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Pointer Declarator Token SPACE"> </span><span class="Token DirectDeclaractor Identifier ID">attr</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration COMMENT">// 复制属性</span><span class="Token Declaration LF">
</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType INT">int</span><span class="Keyword TypeSpecifier BaseType Token FunctionReturnType SPACE"> </span><span class="Token DirectDeclaractor Identifier FunctionName ID">agcopyattr</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 LPAREN">(</span><span class="TypeSpecifier BaseType Token Keyword VOID">void</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">oldobj</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="TypeSpecifier BaseType Token Keyword VOID">void</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">newobj</span><span class="Declarator Token DirectDeclaractor BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><h2 id="h2-9">Internal Attributes</h2><p>只使用字符串属性完全是可能的.然而,通常来说这样做效率太低下了.为了解决这个问题,每个图形对象(图形、节点或边)都可以有一个相关的内部数据记录列表.每个记录的布局是由程序员定义的,除了每个记录都必须有一个 <code>Agrec_t</code> 头.这些记录是通过Cgraph分配的.例如:</p><pre class="language-c"><code><span class="Token Keyword StorageType TYPEDEF">typedef</span><span class="Token Keyword StorageType SPACE"> </span><span class="Structure Keyword StructureType TypeSpecifier Token STRUCT">struct</span><span class="Structure Keyword StructureType TypeSpecifier Token SPACE"> </span><span class="Structure StructureClass TypeSpecifier Identifier Token ID">mynode_s</span><span class="Structure StructureClass TypeSpecifier Identifier Token SPACE"> </span><span class="BraceDepth-0 Token Structure LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agrec_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="TypeSpecifier Token DirectDeclaractor Identifier ID">h</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="StructDeclaration Token SPACE">    </span><span class="TypeSpecifier BaseType Token Keyword INT">int</span><span class="TypeSpecifier BaseType Token Keyword SPACE"> </span><span class="TypeSpecifier Token DirectDeclaractor Identifier ID">count</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="BraceDepth-0 Token Structure RCURLY_BRACE">}</span><span class="Token Structure SPACE"> </span><span class="Token DirectDeclaractor Identifier Typedefine ID">mynode_t</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">mynode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">data</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">Agnode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Token DirectDeclaractor Identifier ID">n</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="PrimaryExpression Token Identifier FunctionCall ID">agnode</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">g</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="String Token STRING">&quot;mynodename&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="PrimaryExpression Token Identifier MacroDefine ID">TRUE</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="PrimaryExpression Token Identifier ID">data</span><span class="PrimaryExpression Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="BraceDepth-0 Token CastExpression ConditionalExpression LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">mynode_t</span><span class="TypeSpecifier Token Keyword Typedefine SPACE"> </span><span class="Pointer AbstractDeclarator Token POINTER">*</span><span class="BraceDepth-0 Token CastExpression ConditionalExpression RPAREN">)</span><span class="PrimaryExpression Token Identifier FunctionCall ID">agbindrec</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression LPAREN">(</span><span class="PrimaryExpression Token Identifier ID">n</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="String Token STRING">&quot;mynode_t&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token Keyword UnaryExpression SIZEOF">sizeof</span><span class="BraceDepth-1 Token CastExpression UnaryExpression LPAREN">(</span><span class="TypeSpecifier Token Keyword Typedefine TYPEDEF_ID">mynode_t</span><span class="BraceDepth-1 Token CastExpression UnaryExpression RPAREN">)</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="PrimaryExpression Token Identifier MacroDefine ID">FALSE</span><span class="BraceDepth-0 Token PostfixExpression UnaryExpression RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="PrimaryExpression Token Identifier ID">data</span><span class="Token PostfixExpression UnaryExpression POINT">-&gt;</span><span class="Token Identifier ID">count</span><span class="Token Identifier SPACE"> </span><span class="AssignmentExpression Token AssignOp ASSIGN">=</span><span class="AssignmentExpression Token AssignOp SPACE"> </span><span class="Constant Token PrimaryExpression NUMBER">1</span><span class="ExpressionStatement Token SEMI">;</span></code></pre><p>类似地,aggetrec会搜索记录,如果记录存在则返回指向该记录的指针,否则返回NULL;agdelrec从对象中删除记录.虽然每个图形对象可能有自己独特的记录集合,但为了方便起见,有一些函数可以通过一次性为所有节点、边或子图分配或删除相同的记录来更新整个图形.这些函数包括:</p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/快速开始" >快速开始</a></li></ul><ul><li><a href="../../md-docs/dot" >dot</a></li></ul><ul><li><a href="../../md-docs/cgraph-pdf" >cgraph-pdf</a></li></ul><ul><li><a href="../../md-docs/C-API" >C-API</a></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../md-docs/dot","../../md-docs/C-API","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>